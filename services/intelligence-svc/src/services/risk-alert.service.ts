import { PrismaClient } from '@prisma/client';
import { RiskCategory, RiskLevel } from '../types/intelligence.types.js';
import type {
  RiskAlertCreateInput,
  RiskAlertUpdateInput,
} from '../types/intelligence.types.js';

export class RiskAlertService {
  constructor(private prisma: PrismaClient) {}

  /**
   * Create a risk alert
   */
  async createAlert(input: RiskAlertCreateInput) {
    const alert = await this.prisma.engagementRiskAlert.create({
      data: {
        contractId: input.contractId,
        riskCategory: input.riskCategory,
        riskLevel: input.riskLevel,
        title: input.title,
        description: input.description,
        indicators: input.indicators,
        suggestedActions: input.suggestedActions,
        autoGenerated: input.autoGenerated ?? false,
        acknowledged: false,
        resolved: false,
      },
    });

    return alert;
  }

  /**
   * Get alert by ID
   */
  async getAlertById(id: string) {
    const alert = await this.prisma.engagementRiskAlert.findUnique({
      where: { id },
    });

    return alert;
  }

  /**
   * Get alerts for a contract
   */
  async getContractAlerts(
    contractId: string,
    options?: {
      resolved?: boolean;
      acknowledged?: boolean;
      riskLevel?: RiskLevel;
    }
  ) {
    const { resolved, acknowledged, riskLevel } = options || {};

    const where: any = { contractId };
    if (resolved !== undefined) where.resolved = resolved;
    if (acknowledged !== undefined) where.acknowledged = acknowledged;
    if (riskLevel) where.riskLevel = riskLevel;

    const alerts = await this.prisma.engagementRiskAlert.findMany({
      where,
      orderBy: [{ riskLevel: 'desc' }, { createdAt: 'desc' }],
    });

    return alerts;
  }

  /**
   * Acknowledge an alert
   */
  async acknowledgeAlert(id: string, userId: string) {
    const alert = await this.prisma.engagementRiskAlert.update({
      where: { id },
      data: {
        acknowledged: true,
        acknowledgedBy: userId,
        acknowledgedAt: new Date(),
      },
    });

    return alert;
  }

  /**
   * Resolve an alert
   */
  async resolveAlert(id: string, userId: string, resolution: string) {
    const alert = await this.prisma.engagementRiskAlert.update({
      where: { id },
      data: {
        resolved: true,
        resolvedBy: userId,
        resolvedAt: new Date(),
        resolution,
      },
    });

    return alert;
  }

  /**
   * Update alert
   */
  async updateAlert(id: string, input: RiskAlertUpdateInput) {
    const alert = await this.prisma.engagementRiskAlert.update({
      where: { id },
      data: {
        acknowledged: input.acknowledged,
        acknowledgedBy: input.acknowledgedBy,
        acknowledgedAt: input.acknowledged ? new Date() : undefined,
        resolved: input.resolved,
        resolvedBy: input.resolvedBy,
        resolvedAt: input.resolved ? new Date() : undefined,
        resolution: input.resolution,
      },
    });

    return alert;
  }

  /**
   * Get unresolved alerts count
   */
  async getUnresolvedCount(contractId?: string) {
    const where: any = { resolved: false };
    if (contractId) where.contractId = contractId;

    const count = await this.prisma.engagementRiskAlert.count({ where });

    return count;
  }

  /**
   * Auto-generate alerts based on project metrics
   */
  async analyzeAndGenerateAlerts(
    contractId: string,
    metrics: {
      daysSinceLastActivity?: number;
      milestoneDelays?: number;
      budgetOverrun?: number;
      communicationGaps?: number;
      scopeChanges?: number;
    }
  ) {
    const alerts: RiskAlertCreateInput[] = [];

    // Inactivity alert
    if (metrics.daysSinceLastActivity && metrics.daysSinceLastActivity > 7) {
      const level = metrics.daysSinceLastActivity > 14 ? RiskLevel.HIGH : RiskLevel.MEDIUM;
      alerts.push({
        contractId,
        riskCategory: RiskCategory.COMMUNICATION,
        riskLevel: level,
        title: 'Project Inactivity Detected',
        description: `No activity recorded for ${metrics.daysSinceLastActivity} days`,
        indicators: [
          `Last activity: ${metrics.daysSinceLastActivity} days ago`,
          'No messages exchanged',
          'No deliverables submitted',
        ],
        suggestedActions: [
          'Reach out to check on project status',
          'Schedule a catch-up call',
          'Review any blockers or issues',
        ],
        autoGenerated: true,
      });
    }

    // Milestone delay alert
    if (metrics.milestoneDelays && metrics.milestoneDelays > 0) {
      const level = metrics.milestoneDelays > 2 ? RiskLevel.HIGH : RiskLevel.MEDIUM;
      alerts.push({
        contractId,
        riskCategory: RiskCategory.TIMELINE,
        riskLevel: level,
        title: 'Milestone Delays Detected',
        description: `${metrics.milestoneDelays} milestone(s) are past their due date`,
        indicators: [`${metrics.milestoneDelays} overdue milestones`, 'Project timeline at risk'],
        suggestedActions: [
          'Review milestone scope and adjust deadlines if needed',
          'Identify and address blockers',
          'Consider reallocating resources',
        ],
        autoGenerated: true,
      });
    }

    // Budget overrun alert
    if (metrics.budgetOverrun && metrics.budgetOverrun > 0.1) {
      const level = metrics.budgetOverrun > 0.2 ? RiskLevel.HIGH : RiskLevel.MEDIUM;
      alerts.push({
        contractId,
        riskCategory: RiskCategory.BUDGET,
        riskLevel: level,
        title: 'Budget Overrun Risk',
        description: `Project is ${Math.round(metrics.budgetOverrun * 100)}% over budget`,
        indicators: [
          `Budget exceeded by ${Math.round(metrics.budgetOverrun * 100)}%`,
          'Current spending trajectory exceeds allocation',
        ],
        suggestedActions: [
          'Review remaining scope against budget',
          'Discuss budget adjustment with client',
          'Identify cost-saving opportunities',
        ],
        autoGenerated: true,
      });
    }

    // Communication gap alert
    if (metrics.communicationGaps && metrics.communicationGaps > 3) {
      alerts.push({
        contractId,
        riskCategory: RiskCategory.COMMUNICATION,
        riskLevel: RiskLevel.MEDIUM,
        title: 'Communication Gap Detected',
        description: `${metrics.communicationGaps} days without client communication`,
        indicators: ['No client responses to messages', 'Pending questions unanswered'],
        suggestedActions: [
          'Send a follow-up message',
          'Try alternative communication channels',
          'Escalate if necessary',
        ],
        autoGenerated: true,
      });
    }

    // Scope creep alert
    if (metrics.scopeChanges && metrics.scopeChanges > 3) {
      const level = metrics.scopeChanges > 5 ? RiskLevel.HIGH : RiskLevel.MEDIUM;
      alerts.push({
        contractId,
        riskCategory: RiskCategory.SCOPE,
        riskLevel: level,
        title: 'Significant Scope Changes',
        description: `${metrics.scopeChanges} scope changes recorded`,
        indicators: [
          `${metrics.scopeChanges} change requests`,
          'Original requirements significantly modified',
        ],
        suggestedActions: [
          'Review and document all scope changes',
          'Assess impact on timeline and budget',
          'Consider contract amendment if needed',
        ],
        autoGenerated: true,
      });
    }

    // Create all alerts
    const createdAlerts = await Promise.all(alerts.map((alert) => this.createAlert(alert)));

    return createdAlerts;
  }

  /**
   * Get alert statistics
   */
  async getAlertStats(contractId?: string) {
    const where: any = {};
    if (contractId) where.contractId = contractId;

    const [total, unresolved, byCategory, byLevel] = await Promise.all([
      this.prisma.engagementRiskAlert.count({ where }),
      this.prisma.engagementRiskAlert.count({
        where: { ...where, resolved: false },
      }),
      this.prisma.engagementRiskAlert.groupBy({
        by: ['riskCategory'],
        where,
        _count: true,
      }),
      this.prisma.engagementRiskAlert.groupBy({
        by: ['riskLevel'],
        where,
        _count: true,
      }),
    ]);

    return {
      total,
      unresolved,
      resolved: total - unresolved,
      byCategory: byCategory.map((c: { riskCategory: string; _count: number }) => ({
        category: c.riskCategory,
        count: c._count,
      })),
      byLevel: byLevel.map((l: { riskLevel: string; _count: number }) => ({
        level: l.riskLevel,
        count: l._count,
      })),
    };
  }

  /**
   * Delete old resolved alerts
   */
  async cleanupOldAlerts(daysOld = 90) {
    const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1000);

    const result = await this.prisma.engagementRiskAlert.deleteMany({
      where: {
        resolved: true,
        resolvedAt: { lt: cutoffDate },
      },
    });

    return { deleted: result.count };
  }
}
