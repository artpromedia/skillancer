/**
 * Vulnerability Scanner
 * SOC 2 compliant vulnerability management
 */

import { randomBytes } from 'crypto';

export interface Vulnerability {
  id: string;
  cveId?: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  cvssScore?: number;
  cvssVector?: string;
  affectedComponent: string;
  affectedVersions?: string;
  remediation?: string;
  discoveredAt: Date;
  status: VulnerabilityStatus;
  assignedTo?: string;
  dueDate?: Date;
  resolvedAt?: Date;
  resolutionNotes?: string;
  source: VulnerabilitySource;
  references: string[];
  tags: string[];
}

export enum VulnerabilitySeverity {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  INFO = 'info',
}

export enum VulnerabilityStatus {
  OPEN = 'open',
  IN_PROGRESS = 'in_progress',
  MITIGATED = 'mitigated',
  RESOLVED = 'resolved',
  ACCEPTED = 'accepted', // Risk accepted
  FALSE_POSITIVE = 'false_positive',
}

export enum VulnerabilitySource {
  DEPENDENCY_SCAN = 'dependency_scan',
  SAST = 'sast', // Static Application Security Testing
  DAST = 'dast', // Dynamic Application Security Testing
  PENETRATION_TEST = 'penetration_test',
  BUG_BOUNTY = 'bug_bounty',
  INTERNAL_AUDIT = 'internal_audit',
  EXTERNAL_AUDIT = 'external_audit',
  CVE_FEED = 'cve_feed',
  MANUAL = 'manual',
}

export interface ScanResult {
  id: string;
  scanType: ScanType;
  startedAt: Date;
  completedAt?: Date;
  status: 'running' | 'completed' | 'failed';
  vulnerabilities: Vulnerability[];
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    total: number;
  };
  scanTarget: string;
  scannerVersion: string;
}

export enum ScanType {
  DEPENDENCY = 'dependency',
  CODE = 'code',
  CONTAINER = 'container',
  INFRASTRUCTURE = 'infrastructure',
  API = 'api',
}

export interface DependencyVulnerability {
  packageName: string;
  currentVersion: string;
  vulnerableVersions: string;
  fixedVersions?: string;
  severity: VulnerabilitySeverity;
  cveId?: string;
  description: string;
  url?: string;
}

// In-memory stores
const vulnerabilities: Map<string, Vulnerability> = new Map();
const scanResults: Map<string, ScanResult> = new Map();

// SLA timelines (in days)
const REMEDIATION_SLA: Record<VulnerabilitySeverity, number> = {
  [VulnerabilitySeverity.CRITICAL]: 1, // 24 hours
  [VulnerabilitySeverity.HIGH]: 7,
  [VulnerabilitySeverity.MEDIUM]: 30,
  [VulnerabilitySeverity.LOW]: 90,
  [VulnerabilitySeverity.INFO]: 180,
};

export class VulnerabilityScanner {
  /**
   * Simulate dependency vulnerability scan
   */
  async scanDependencies(packageJsonPath: string): Promise<ScanResult> {
    const scanId = randomBytes(16).toString('hex');
    const startedAt = new Date();

    const result: ScanResult = {
      id: scanId,
      scanType: ScanType.DEPENDENCY,
      startedAt,
      status: 'running',
      vulnerabilities: [],
      summary: { critical: 0, high: 0, medium: 0, low: 0, info: 0, total: 0 },
      scanTarget: packageJsonPath,
      scannerVersion: '1.0.0',
    };

    scanResults.set(scanId, result);

    // In production, this would call npm audit, snyk, or similar
    // For now, return empty (no vulnerabilities)
    result.status = 'completed';
    result.completedAt = new Date();

    return result;
  }

  /**
   * Simulate code security scan (SAST)
   */
  async scanCode(targetPath: string): Promise<ScanResult> {
    const scanId = randomBytes(16).toString('hex');
    const startedAt = new Date();

    const result: ScanResult = {
      id: scanId,
      scanType: ScanType.CODE,
      startedAt,
      status: 'running',
      vulnerabilities: [],
      summary: { critical: 0, high: 0, medium: 0, low: 0, info: 0, total: 0 },
      scanTarget: targetPath,
      scannerVersion: '1.0.0',
    };

    scanResults.set(scanId, result);

    // Checks for common code vulnerabilities
    const checks = [
      { pattern: /eval\s*\(/, issue: 'Eval usage detected', severity: VulnerabilitySeverity.HIGH },
      {
        pattern: /innerHTML\s*=/,
        issue: 'innerHTML assignment (XSS risk)',
        severity: VulnerabilitySeverity.MEDIUM,
      },
      {
        pattern: /dangerouslySetInnerHTML/,
        issue: 'dangerouslySetInnerHTML usage',
        severity: VulnerabilitySeverity.MEDIUM,
      },
      {
        pattern: /exec\s*\(/,
        issue: 'Command execution detected',
        severity: VulnerabilitySeverity.CRITICAL,
      },
      {
        pattern: /password\s*[=:]\s*['"][^'"]+['"]/,
        issue: 'Hardcoded password',
        severity: VulnerabilitySeverity.CRITICAL,
      },
      {
        pattern: /api[_-]?key\s*[=:]\s*['"][^'"]+['"]/,
        issue: 'Hardcoded API key',
        severity: VulnerabilitySeverity.HIGH,
      },
      {
        pattern: /TODO.*security/i,
        issue: 'Security TODO found',
        severity: VulnerabilitySeverity.INFO,
      },
    ];

    // In production, would scan actual files
    result.status = 'completed';
    result.completedAt = new Date();

    return result;
  }

  /**
   * Register a manually discovered vulnerability
   */
  async registerVulnerability(
    vuln: Omit<Vulnerability, 'id' | 'discoveredAt' | 'status'>
  ): Promise<Vulnerability> {
    const id = randomBytes(16).toString('hex');
    const discoveredAt = new Date();
    const dueDate = new Date(discoveredAt);
    dueDate.setDate(dueDate.getDate() + REMEDIATION_SLA[vuln.severity]);

    const vulnerability: Vulnerability = {
      ...vuln,
      id,
      discoveredAt,
      status: VulnerabilityStatus.OPEN,
      dueDate,
    };

    vulnerabilities.set(id, vulnerability);
    return vulnerability;
  }

  /**
   * Update vulnerability status
   */
  async updateVulnerability(
    id: string,
    updates: Partial<Omit<Vulnerability, 'id' | 'discoveredAt'>>
  ): Promise<Vulnerability | null> {
    const vuln = vulnerabilities.get(id);
    if (!vuln) return null;

    const updated = { ...vuln, ...updates };

    // Set resolved date if status changed to resolved
    if (
      updates.status === VulnerabilityStatus.RESOLVED &&
      vuln.status !== VulnerabilityStatus.RESOLVED
    ) {
      updated.resolvedAt = new Date();
    }

    vulnerabilities.set(id, updated);
    return updated;
  }

  /**
   * Get all vulnerabilities with optional filters
   */
  async getVulnerabilities(filters?: {
    severity?: VulnerabilitySeverity[];
    status?: VulnerabilityStatus[];
    source?: VulnerabilitySource[];
    overdue?: boolean;
  }): Promise<Vulnerability[]> {
    let results = Array.from(vulnerabilities.values());
    const now = new Date();

    if (filters) {
      if (filters.severity && filters.severity.length > 0) {
        results = results.filter((v) => filters.severity!.includes(v.severity));
      }
      if (filters.status && filters.status.length > 0) {
        results = results.filter((v) => filters.status!.includes(v.status));
      }
      if (filters.source && filters.source.length > 0) {
        results = results.filter((v) => filters.source!.includes(v.source));
      }
      if (filters.overdue) {
        results = results.filter(
          (v) =>
            v.dueDate &&
            v.dueDate < now &&
            ![
              VulnerabilityStatus.RESOLVED,
              VulnerabilityStatus.ACCEPTED,
              VulnerabilityStatus.FALSE_POSITIVE,
            ].includes(v.status)
        );
      }
    }

    return results;
  }

  /**
   * Get vulnerability metrics for dashboard
   */
  async getMetrics(): Promise<{
    total: number;
    open: number;
    overdue: number;
    bySeverity: Record<string, number>;
    byStatus: Record<string, number>;
    mttr: number; // Mean Time To Remediate (days)
    slaCompliance: number; // Percentage
  }> {
    const all = Array.from(vulnerabilities.values());
    const now = new Date();

    const open = all.filter(
      (v) =>
        ![
          VulnerabilityStatus.RESOLVED,
          VulnerabilityStatus.ACCEPTED,
          VulnerabilityStatus.FALSE_POSITIVE,
        ].includes(v.status)
    );

    const overdue = open.filter((v) => v.dueDate && v.dueDate < now);

    const bySeverity: Record<string, number> = {};
    const byStatus: Record<string, number> = {};

    for (const vuln of all) {
      bySeverity[vuln.severity] = (bySeverity[vuln.severity] || 0) + 1;
      byStatus[vuln.status] = (byStatus[vuln.status] || 0) + 1;
    }

    // Calculate MTTR from resolved vulnerabilities
    const resolved = all.filter((v) => v.status === VulnerabilityStatus.RESOLVED && v.resolvedAt);
    let totalDays = 0;
    let resolvedInSla = 0;

    for (const vuln of resolved) {
      const resolvedTime = vuln.resolvedAt!.getTime();
      const days = (resolvedTime - vuln.discoveredAt.getTime()) / (1000 * 60 * 60 * 24);
      totalDays += days;

      if (days <= REMEDIATION_SLA[vuln.severity]) {
        resolvedInSla++;
      }
    }

    return {
      total: all.length,
      open: open.length,
      overdue: overdue.length,
      bySeverity,
      byStatus,
      mttr: resolved.length > 0 ? Math.round(totalDays / resolved.length) : 0,
      slaCompliance:
        resolved.length > 0 ? Math.round((resolvedInSla / resolved.length) * 100) : 100,
    };
  }

  /**
   * Get overdue vulnerabilities for alerting
   */
  async getOverdueAlerts(): Promise<Vulnerability[]> {
    return this.getVulnerabilities({ overdue: true });
  }

  /**
   * Generate vulnerability report for compliance
   */
  async generateReport(
    startDate: Date,
    endDate: Date
  ): Promise<{
    period: { start: Date; end: Date };
    summary: {
      discovered: number;
      resolved: number;
      open: number;
      overdue: number;
    };
    bySource: Record<string, number>;
    bySeverity: Record<string, { discovered: number; resolved: number }>;
    topAffectedComponents: { component: string; count: number }[];
    slaCompliance: number;
    mttr: number;
    vulnerabilities: Vulnerability[];
  }> {
    const all = Array.from(vulnerabilities.values());
    const inPeriod = all.filter((v) => v.discoveredAt >= startDate && v.discoveredAt <= endDate);

    const resolved = inPeriod.filter(
      (v) => v.resolvedAt && v.resolvedAt >= startDate && v.resolvedAt <= endDate
    );

    const open = inPeriod.filter(
      (v) =>
        ![
          VulnerabilityStatus.RESOLVED,
          VulnerabilityStatus.ACCEPTED,
          VulnerabilityStatus.FALSE_POSITIVE,
        ].includes(v.status)
    );

    const overdue = open.filter((v) => v.dueDate && v.dueDate < new Date());

    const bySource: Record<string, number> = {};
    const bySeverity: Record<string, { discovered: number; resolved: number }> = {};
    const componentCounts: Record<string, number> = {};

    for (const vuln of inPeriod) {
      bySource[vuln.source] = (bySource[vuln.source] || 0) + 1;

      if (!bySeverity[vuln.severity]) {
        bySeverity[vuln.severity] = { discovered: 0, resolved: 0 };
      }
      bySeverity[vuln.severity].discovered++;

      if (vuln.status === VulnerabilityStatus.RESOLVED) {
        bySeverity[vuln.severity].resolved++;
      }

      componentCounts[vuln.affectedComponent] = (componentCounts[vuln.affectedComponent] || 0) + 1;
    }

    const topAffectedComponents = Object.entries(componentCounts)
      .map(([component, count]) => ({ component, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    // Calculate MTTR
    let totalDays = 0;
    let resolvedInSla = 0;

    for (const vuln of resolved) {
      if (vuln.resolvedAt) {
        const days =
          (vuln.resolvedAt.getTime() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60 * 24);
        totalDays += days;

        if (days <= REMEDIATION_SLA[vuln.severity]) {
          resolvedInSla++;
        }
      }
    }

    return {
      period: { start: startDate, end: endDate },
      summary: {
        discovered: inPeriod.length,
        resolved: resolved.length,
        open: open.length,
        overdue: overdue.length,
      },
      bySource,
      bySeverity,
      topAffectedComponents,
      slaCompliance:
        resolved.length > 0 ? Math.round((resolvedInSla / resolved.length) * 100) : 100,
      mttr: resolved.length > 0 ? Math.round(totalDays / resolved.length) : 0,
      vulnerabilities: inPeriod,
    };
  }
}

export const vulnerabilityScanner = new VulnerabilityScanner();
